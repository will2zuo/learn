## GMP 模型
#### G：goroutine => 需要绑定 P 才能运行，在 G 的视角中，P就是 CPU

#### P：承上启下的调度器
1. 承上启下，实现 G 和 M 的动态有机结合
2. 对于 g 来说，只有被 p 调用才能运行
3. 对于 m 来说，是 m 的执行代理
4. p 的数量决定了g 的并发数量，可以用过 runtime.GOMAXPROCS 来设定

调度器的策略
1. work stealing机制 : 当本线程无可运行的g 时，尝试从其他线程绑定的 p 偷取g，而不是销毁线程
2. hand off 机制 : 当本线程因为g 进行系统调用阻塞时，就释放绑定的 p，把 p 转移给其他空闲的线程执行

#### M：machine，go 中对线程的抽象 => m 不直接执行 g，由 p 代理执行

#### GMP 模型调度的过程
![gmp.png](gmp.png)
1. 全局队列：存放的是等待运行的 g
2. p 的本地队列：和全局队列一样，存放的是等待运行的 g，存的数量有限，不超过 256 个。新建 g 时，g 优先加入p 的本地队列，如果队列满了，泽辉把本地队列中的一半的 g 移动到全局队列
3. p 列表：所有的 p 都在程序启动时创建，并保存到数组中，最多有 gomaxprocs（可配置） 个
4. m：线程相运行任务就得先获取 p，从 p 的本地队列获取 g，p 队列为空，m 也会尝试从全局队列拿一批 g 放到 p 的本地队列，或者从其他 p 偷取一半放到自己 p 的本地队列。m 运行 g，g 执行之后，m 会从 p 获取下一个 g，不断重复

#### go func 的调度流程
![img.png](img.png)

#### 调度器的生命周期
![img_1.png](img_1.png)

## Go 的垃圾回收机制
### 垃圾回收分类
1. 追踪式：从根对象出发，根据对象之间的引用关系，一步步推进知道扫描整个堆并确定要保留的对象，从而进行垃圾回收
2. 引用计数式：每个对象包含一个引用计数器，当引用计数器归零的时候就会被回收

### 根对象是什么
又叫做根集合，在垃圾回收过程中最先检查的对象：
1. 全局变量
2. 执行栈
3. 寄存器

### 三色标记法
1. 从所有根对象开始遍历，可达的先标记为灰色
2. 遍历所有灰色，变为黑色，再将可达的白色变为灰色
3. 重复第二步，直到遍历完所有对象，剩下的黑色则是可以存活的对象，白色的则是需要回收的对象

三色标记法也会存在 stw，gc 效率过低的问题，解决方法 => 写屏障、混合写屏障

如果不使用 stw ，会存在合法的对象也被 gc 给回收掉了

### 屏障机制
当以下两个条件同时满足时会破坏垃圾回收器的正确性：
1. 一个白色对象被黑色对象引用(白色被挂在黑色下)
2. 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)

为了保证gc 回收时，对象不被丢失：
1. 强三色不变式：既不存在黑色的对象引用白色的对象
2. 弱三色不变式：既所有黑色引用到的白色对象，都有可达的路径，这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象

#### 插入屏障
满足强三色不变式：既A 对象引用对象 B，B会被标记为灰色

#### 删除屏障
满足弱三色不变式：既被删除的对象，如果自身为灰色或者白色，那么标记为灰色

#### 混合写屏障
满足变式的弱三色不变式，结合了插入屏障和删除屏障的有点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。

流程：
1. gc 开始将栈上的所有对象标记为黑色，之后不会重复扫描，不需要stw
2. gc 期间，任何在栈上创建的对象，均为黑色
3. 被删除的对象标记为灰色【删除屏障】
4. 被添加的对象标记为回味【插入屏障】

混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高
## Go Map 的实现