#### 群聊消息存储方案
1. 群聊消息存多份，只存离线成员的消息，如果在实时给在线成员推消息失败的情况，会导致消息丢失
2. 群聊消息存多份，所有群友都存储，消息冗余多； 先落盘，等 ack 确认之后在进行删除，磁盘带宽占用大
3. 群聊消息存多份，只存未读ID的集合，未利用偏序；
4. 群聊消息存一份，只存最近最后一次的消息 id，last_ack_msgid。拉离线消息根据这个 id 往后拉就 ok

   group_members(gid, uid, last_ack_msgid);
   group_msgs(msgid,gid,sender_uid,time,content);

#### go 的互斥锁，读写锁，sync.map
- var mutex sync.Mutex
- var mutex sync.RWMutex
- var m sync.Map

#### sync.map 怎么实现
1. 读写分离，一个 read，读的字段只读 read 上的； 和一个 dirty，新写的字段 在 dirty字段上
2. 读取的时候先读 read 里，如果没有在读 dirty
3. 读 read 的时候不需要加锁，读或者写 dirty 需要加锁
4. misses 字段来记录击穿的次数（misses = len（dirty）），达到一定次数就会将 dirty 的数据缓存到 read 里
5. 适合多读少写的场景
6. 对于删除是通过标记 amended 来延迟删除，是在 store 中删除

#### having 和 where 的区别
having 从分组的结果中再次筛选，where 过滤的是行

#### mysql 中删除数据之后，磁盘的占用仍然很大
1. 删除数据之后，磁盘并没有立即释放出来，而是被标记为空闲状态，为了提高性能，避免频繁的磁盘分配和回收操作
   解决办法：用 optimize table 来释放碎片化的磁盘空间；但是这个操作会锁表，造成短暂的不可用

#### 网关设计：
需要做的事情：
1. 协议转换 rpc 转 http 或者 http 转 rpc
2. 统一鉴权、统一监控、服务熔断、降级、流量控制、路由转发、服务发现、异步调用、链路调用

#### mq作用：解耦、异步处理、削峰填谷
#### mq 面临的问题：
- 重复消费的问题；
    - 费幂等性：
        - 保证幂等性：在 mq 数据持久化设置一个全局的唯一 msgid，还有 redis 的 set
        - 保证幂等性：一样可以用全局唯一的 msgid 来判断，还有 redis 的 set

- 靠性传输问题/保证消息不丢失
  - 发送端 ： 重试机制，保证消息投递成功，收到 mq server 的 ack 确认就认为消息投递成功
  - server: 数据持久化，集群模式 kafka 的 topic 有 n 个 partition ，每个 partition 在不同机器上还有副本
  - 消费端：手动 ack 确认或者 offset

- 使用事务的方式，阻塞的等待成功或者失败，会导致吞吐量减少
  - confirm 确认，异步不会造成阻塞
  - 持久化成功之后在进行 confirm 回调通知
  - 消费者主动 ack或 offset 确认

- 如何保证消息的顺序性
  - 通过指定 key 的方式落在同一个 partition 中，同一个 partition 保证是有序的
    或者 在同一个 queue 中

- 怎么快速处理积压的消息
  - 快速修复 consumer，保证能正常消息
  - 增加机器来加快消费，或者是新建一个更大的 queue 来存储未消费的消息，等空闲时间慢慢消费
  - 如果是过期消息被丢弃了，只能重新写个脚本来重新查询被丢弃的消息重新进行消费
  - 如果长期处理不了，只能采用丢弃+批量重导的方式，在闲暇时间再来查询修复

- 如何设计一个 mq
  - 支持伸缩扩容机制，
  - 支持数据持久化，避免消息丢失
  - 高可用，leader -> 多副本->borber
  - 支持数据 0 丢失


#### 限流：
- 计数限流: 在固定时间内限制固定的请求数量，但是存在在重置节点突发【节点前后请求最大请求数量】请求超过限制
- 令牌桶限流：桶的大小固定，令牌生成的速度固定，消耗令牌的速度不固定，每次请求都会从桶里取令牌，如果没有令牌就丢弃这次请求，能动态调整令牌发放的速度，针对突发流量
- 漏桶限流：桶的大小固定，消费的速度固定

sync.groupWait() 底层的实现

#### mysql 大数据量处理
1. 分区
2. 分表分库
3. 读写分离
4. 数据库集群
5. 冷热数据归档
6. 优化查询 sql 语句



#### 分表分库存在的问题
1. 迁移和扩容的问题；
   解决：使用在线迁移工具，如阿里云的DTS和腾讯云的CDM
2. 跨库查询性能的问题；跨库 join 问题
   尽量避免跨库查询；或者是讲关联的操作提前到应用层；或者是用一些中间件、mycat 来优化关联查询
3. 数据一致性问题；
   分布式事务或者redis 分布式锁来解决
4. 跨库分布式事务的问题；
   可以使用两段提交 （2pc）或者三段提交来解决 （3pc），或者一些支持分布式事务的中间件，如阿里巴巴的 TDDL 或者当当网的 Sharding-JDBC
5. 自增 id 重复，插入性能下降
   1. 分布式 id 生成器【雪花算法】来生成唯一 id，这些算法通常使用时间戳、机器 ID 和序列号的组合来确保 ID 的全局唯一性，同时保持高性能
   2. uuid，UUID 是全局唯一的，但长度较长（通常为 36 个字符），可能会影响性能和存储空间
   3. id 段分配，可能导致 id 浪费
   4. 双主键，一个字段是自增 id，一个是分片的 id



#### 分表分库的类型以及方案
- 水平分表分库: 按照数据行以 range 或者 hash 或者去模的方式分，表相同但是数据不同，库相同但是表不同 user_0 user_1
- 垂直分表分库: 按照字段来分，分库是按照模块来分，order。user

#### mysql 分区是什么
- 分区是指将大表分成小表，但是物理上仍然是一个表，分布在不同的磁盘上，但是查询数据还是向普通表一样
- 作用：提高查询性能，减少 io 操作，同时也方便管理数据


#### http1 和 http2 的区别
1. 连接复用，提高了传输的效率
2. 二进制传输，http1是文本传输，更快的解析速度和更小的数据包大小，减少了传输时间和延迟
3. 头部压缩，htt1 每次传输都是要重复发送头部信息，http2压缩头部信息，减少了传数量，加快了传输速度
4. 流优先级，http2 允许为每个流设置优先级，使得重要资源有限传输
5. 流量控制

#### put 和 patch 的区别：
1. put 是幂等的，patch 不一定是幂等的；
2. put 是替换整个资源，patch 是替换部分资源

#### 如何实现一个死锁
两个事务，一个是先更新 id=1，再更新 id=2 的；另一个事务是先更新 id=2 的，再去更新 id=1；