#### url 访问网站的过程

1. dns 解析，将域名解析为 ip 地址

2. tcp 连接，tcp 的三次握手

   - 由浏览器发起，告诉服务器要开始请求数据了 发起 syn
     
   - 由服务器发起，告诉了浏览器准备好了接收数据，可以发起请求 回复 syn 并ACK 客户端的 syn

   - 由浏览器发起，告诉服务器马上发送数据，准备接收，收到服务端的 syn，发送对服务端的 syn 的 ack

3. 发送请求

4. 接收响应

5. 渲染页面

6. 断开连接，tcp 的四次挥手

   - 由浏览器发起，告诉服务器请求报文发送完毕，准备关闭

   - 由服务器发起，告诉浏览器，请求报文接收完毕，准备关闭，你也准备关闭

   - 由服务器发起，告诉浏览器，响应报文发送完毕，你准备关闭

   - 由浏览器发起，告诉服务器，响应报文接收完毕，准备关闭

## TCP 三次握手、四次挥手
### 三次握手
![img.png](img.png)

### 四次挥手
![img_1.png](img_1.png)

#### 常见的 http 状态码

> 1xx：请求被接收
>
> 2xx：成功
>
> 3xx：重定向
>
> 4xx：客户端错误
>
> 5xx：服务器错误

```
301:永久重定向
302:临时重定向
401:权限不足，请求认证用户身份信息
403:拒绝访问
404:无法找到请求的资源
405:客户端请求中的方法被禁止
500:服务器内部错误
501:此请求方法不被服务器支持且无法被处理
502:网关错误
503:服务器繁忙
504:不能及时响应
```

#### osi 的七层模型 和 tcp/ip 四层关系

<table>
   <tr>
        <td>OSI 七层网络模型</td>
        <td>TCP/IP四层概念模型</td>
        <td>对应网络协议</td>
    </tr>
    <tr>
        <td>应用层</td>
        <td rowspan="3">应用层</td>
        <td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
    </tr>
    <tr>
        <td>表示层</td>
        <td>Telnet, Rlogin, SNMP, Gopher</td>
    </tr>
    <tr>
        <td>会话层</td>
        <td>SMTP, DNS</td>
    </tr>
    <tr>
        <td>传输层</td>
        <td>传输层</td>
        <td>TCP, UDP</td>
    </tr>
    <tr>
        <td>网络层</td>
        <td>网络层</td>
        <td>IP, ICMP, ARP, RARP, AKP, UUCP</td>
    </tr>
    <tr>
        <td>数据链路层</td>
        <td rowspan="2">数据链路层</td>
        <td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td>
    </tr>
    <tr>
        <td>物理层</td>
        <td>IEEE 802.1A, IEEE 802.2到IEEE 802.11</td>
    </tr>
</table>

![img_2.png](img_2.png)

#### linux 发送接受网络包流程
![img_3.png](img_3.png)

#### 跨域怎么出现的，怎么解决跨域

**出现**：浏览器的同源策略，限制了一个源的文件或者脚本如何和另一个源的资源进行交互，如果没有同源策略，容易收到 XSS/CSRF 等攻击

**解决**：

1. jsonp，利用 <script> 标签没有跨域限制的漏洞，页面可以动态的得到其他源的 json 数据

   - 优点：兼容性好，可以用于主流浏览器的跨域访问问题
   - 缺点：仅支持 get 方法；不安全，容易遭受 xss 攻击

2. cors 跨域资源共享，分为简单请求和复杂请求

   - 简单请求
   - 复杂请求，在正式请求之前，增加一次 http 查询请求

3. nginx 的反向代理

   配置一个代理服务器做跳板机

4. node 中间件代理（两次跨域）

   实现原理：就是服务器向服务器请求

#### get 和 post 的区别
